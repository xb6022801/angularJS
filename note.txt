Angular学习笔记
-----------------
自动初始化 <html ng-app>
初始化时机： DOMContentLoaded or document.readyState = 'complete'
or
手动初始化： angular.bootstrap(,,)
延迟启动: when window.name contain NO_DEFER_BOOTSTRAP!， then wait resumeBootstrap()

一些基本概念: template, directive, filter, expression, Model, view, controller, compiler, injector, 
Dependency injection, module, scope, service

ng-app='rootId'
ng-controller = 'DemoController as Peseudo'： 负责管理这个节点以及子节点
ng-init='expression'
ng-repeat = 'node in nodeList'
ng-model

controller: 一个构造函数，用处是倒出一些变量和函数，以便expression和directives调用。
module: 创建了一个模块，在这个模块上注册了这个controller

可以将与视图无关的逻辑从controller里提出来，封装到services里。

module.controller(controller_name, [...arrays of Dependency services, constructor]): 做成数组模式是怕被js minifer压缩
参数名字，而常规的依赖注入需要根据参数名字来查找‘被注入对象的’  (invoice1.js)

$http: 它是由angular构造的访问后端API服务，是对XMLHttpRequest和JSONP的封装。

编译html
angularJS用的是DOM模版而非字符串模版，编译阶段返回的是一个link function(连接函数)，
$compile(DOM模版)， 调用之前先angular.element(字符串) --> DOM模版
编译阶段：
- $compile遍历DOM，匹配指令
- 按照指令的priority排列指令的执行顺序，然后依次执行directive的compile函数，每个compile函数返回一个link函数，这些函数共同
拼接成一个link函数。
-$compile调用step2的link函数，将模板和scope对接。该阶段会依次调用每个指令的link函数，进而在DOM元素上设置监听器，以及在scope上
设置$watch

res: 得到了一个作用域和scope绑定的实时视图(runtime view)

compile阶段被分为了compile和link两个阶段：
directives一般没有compile fn，但肯定有link fn。
directives创造isolated scope for directive

自定义指令:
x-*, data-*, ngBind, ng-bind, ng:bind等等，都可以匹配到。
指令注册在模块上，module.directive()
  restrict: A/E/AE (匹配属性名/匹配元素名/都匹配)
  templateUrl: like ngInclude
  可以使用scope来创造隔离作用域，这样也无法访问controller的变量.如果要使你的组件在应用范围内可重用，
  那么使用scope选项去创建一个独立作用域

  操作DOM通常在link: function (scope, element, attrs){}中定义: scope (angular中的是scope， element是angular
  内部jqLite封装的对象，attrs 驼峰形式的属性值对)

  transclude: true (相当于vue里的slot)， 如果directive里定义了scope，则无论是否在link函数里定义了scope什么的，transclude
  依然访问外部作用域，link里改写scope(directive的scope)不影响transclude的解析。但是如果directive不是isolated scope，则在
  link里的scope是父级作用域，改写的话会有问题。

  scope {
    localAttr: '=fatherScope_attr' || sameNameAttr: '=',
    localAction: '&fatherScope_prop' || samePropName: '& (index3.html)
  }

(service: $timeout, $interval)

directives之间的互相通信：(index4.html)
directive里也可以定义controller。--> 如果想暴露内部方法给别的directive的话，用controller
另一个directive里用 require: '^^controllerName' (两个^在parent的controller里找，1个^在parent or self的controller里找，
没有的话在self controller里找)，这个controller在link里是第四个参数。 
controller可以是个array： require: ['^^parentContraoller1', 'selfController2']

双向数据绑定：同时也方便测试

controller： 
intialize $scope object, add behavior and functions for $scope.
controller should contains business logics only.

this keeps the controller's constructor function out of the global scope.
expression还可以这么写 in inline style: 
method: function double()
然后: {{ double(args) }}

The most common way to keep Controllers slim is by encapsulating work that doesn't belong to controllers into services
 and then using these services in Controllers via dependency injection

ngController='SpicyController' (建议最好大写)

controller之间的scope的继承： 根据我现在的理解，基本就是继承关系。子scope可以override parent scope的属性。
MainController
  ChildController
    GrandChildController

这个例子里有4个scope: rootScope + 3 scopes of controllers

SERVICES：
- lazily instantiated; - Singletons – Each component dependent on a service gets a reference to the single 
  instance generated by the service factory.

useful build-in services such as : $http, $interval, $timeout, $log, etc
service的调用方法取决于service的return对象。(services/index.html)

create services: Application developers are free to define their own services by registering the service's
name and service factory function, with an Angular module.
return: function | object

第二种注册service的方法： via the $provide service inside of a module's config function:
(This technique is often used in unit tests to mock out a service's dependencies.)

=====================================
PROVIDERS:
Value：只能运行阶段访问。

就像Value图纸一样，Factory图纸能创建任何类型的服务，不管是原生类型，对象常量，函数，甚至自定义类型的实例。

service: 适用于创造自定义类型。

Provider图纸从语法上来说，只是一个实现了$get方法的自定义类型。
当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到Provider图纸。
在应用引导阶段，也就是在Angular开始创建服务之前，Angular配置和实例化所有provider。我们把这个过程称为应用生命周期的配置阶段。
在这个阶段中，服务不能被访问，因为它们根本都还没有被创建
一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始。我们把应用生命周期的这个阶段叫做运行阶段。

constant图纸：
既然配置函数运行在没有服务可用的配置阶段，那么它就连由Value图纸创建的简单值对象都无法访问。
constant: 配置和运行阶段都可以访问 --> 存在的意义。

专用对象：早先我们也提到过和服务不同的专用对象。这些对象作为插件扩展了Angular框架，因此必须实现Angular指定的接口。这些接口就是控制器，指令，过滤器和动画。
创建这些专用对象（控制器对象除外）的注入器指令幕后其实使用的也是Factory图纸。

综上所述，我们总结如下最重要的几点：
注入器使用图纸创建两类对象：服务和专用对象。
总共有5类图纸来定义如何创建对象：Value，Factory，Service，Provicer以及Constant。
Factory和Service是最常用的图纸。它们之间的唯一区别就是Service图纸在创建自定义对象时更适用，而Factory还可以创建Javascript原始类型以及函数。
Provider图纸是最核心的图纸类型，而其它所有图纸都只是基于它的语法糖。
Provider也是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它。
除了控制器，其他所有专用对象都是通过Factory图纸来定义的。

=====================================

SCOPE: 作用域
作用域可以监听 表达式 的变化并传播事件 ($watch)
During the template linking phase the directives set up $watch expressions on the scope.:
controller - scope -view
directive - scope - view
controller and directive 之间并没有直接联系。scope扮演了粘合剂的作用。

Notice that Angular automatically places ng-scope class on elements where scopes are attached.
从DOM元素中抓取scope： angular.element($0).scope(); $rootScope在 ngApp节点上抓取。

scope之间相当于js里的原型继承。

基于scope的事件传播： broadcasted | emitted
ng-click="$broadcast('MyEvent')" | ng-click="$emit('MyEvent')" 
$scope.$on('MyEvent', fn)

原声js上下文 和 angular执行上下文： 如果当浏览器控制权跑到原生js上下文中，angularjs就无法检测到数据变化了，这时候
需要调用$scope.$apply(expression) 来进入angularJS的上下文。

$apply() --> $digest() (遍历所有$watch监测的表达式并与之前的值比较：dirty check | 异步进行) --> 渲染DOM

scope life cycle:
1. register root scope by $injector; during template linking, directives create children scopes;
2. register watchs of model change
3. scope.$apply() data change process 
4. $digest()
5. $scope.$destroy()

scope and directives:
- type 1： 监测型指令： {{ expression }}， 这些需要在$watch上注册一个监听处理器。
- type 2:  监听型指令： ng-click="fn()", 通过$apply(fn()) 来更新DOM视图

综上，无论是哪种类型的指令，当外部事件（可能是用户输入，定时器，ajax等）发生时，相关的 表达式 必须要通过 $apply() 
作用于相应的作用域，这样所有的监听器才能被正确更新，然后进行后续的相关操作。

=====================================
DEPENDENCY INJECTION
为了分离“创建依赖”的职责，每个 Angular 应用都有一个 injector对象。这个 injector 是一个服务定位器，负责创建和查找依赖。
(三种依赖注入方式.js)

工厂方法负责创建 Angular 中的绝大多数对象。例如指令，服务，和过滤器等

strict dependency injection: 不允许implicite annotation
<html ng-app ng-strict-di> 


TEMPLATE
4 types of elements and attributs allowed to use in templates:
directive, Markup, filters, form controls 

EXPRESSION
不能直接使用window, document, location, use $window, $document, $window instead
不能用control flow such as: {{ a? b: c }}
ng-click, ng-focus 等directive里内置$event (jquery like object)
one-time binding: {{ ::name }} //第一次得到一个un-undefined value就不变化了

Interpolation:
<img src="img/{{relativeUrl}}.jpg" alt="image">
boolean attribute: ng-disabled/checked/selected/required/read-only, etc

ngAttr for binding to arbitrary attributes: ng-attr-cx, etc

You can also access the scope with this in your templates:
<div ng-show="this['form' + $index].$invalid"></div>

do not mix interpolation and expressions is bad practice such as:
<div ng-show="form{{$index}}.$invalid"></div>

===============================
Filters
The underlying API is the $filterProvider.

{{ expression | filter }}
{{ expression | filter1 | filter2 | ... }}
{ expression | filter:argument1:argument2:... }} : e.g. {{ currentNbs | number:2}}
build-in filters: currency, number, date, json, limitTo, orderBy, uppercase, lowercase

基本类型只有值变化的时候才重新执行filter，object类型每次$digest都执行一次。

Using filters in controllers, services, and directives

If you wish to namespace your filters, then you can use capitalization 
(myappSubsectionFilterx) or underscores (myapp_subsection_filterx).