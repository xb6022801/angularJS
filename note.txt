Angular学习笔记
-----------------
自动初始化 <html ng-app>
初始化时机： DOMContentLoaded or document.readyState = 'complete'
or
手动初始化： angular.bootstrap(,,)
延迟启动: when window.name contain NO_DEFER_BOOTSTRAP!， then wait resumeBootstrap()

一些基本概念: template, directive, filter, expression, Model, view, controller, compiler, injector, 
Dependency injection, module, scope, service

ng-app='rootId'
ng-controller = 'DemoController as Peseudo'： 负责管理这个节点以及子节点
ng-init='expression'
ng-repeat = 'node in nodeList'
ng-model

controller: 一个构造函数，用处是倒出一些变量和函数，以便expression和directives调用。
module: 创建了一个模块，在这个模块上注册了这个controller

可以将与视图无关的逻辑从controller里提出来，封装到services里。

module.controller(controller_name, [...arrays of Dependency services, constructor]): 做成数组模式是怕被js minifer压缩
参数名字，而常规的依赖注入需要根据参数名字来查找‘被注入对象的’  (invoice1.js)

$http: 它是由angular构造的访问后端API服务，是对XMLHttpRequest和JSONP的封装。

编译html
angularJS用的是DOM模版而非字符串模版，编译阶段返回的是一个link function(连接函数)，
$compile(DOM模版)， 调用之前先angular.element(字符串) --> DOM模版
编译阶段：
- $compile遍历DOM，匹配指令
- 按照指令的priority排列指令的执行顺序，然后依次执行directive的compile函数，每个compile函数返回一个link函数，这些函数共同
拼接成一个link函数。
-$compile调用step2的link函数，将模板和scope对接。该阶段会依次调用每个指令的link函数，进而在DOM元素上设置监听器，以及在scope上
设置$watch

res: 得到了一个作用域和scope绑定的实时视图(runtime view)

compile阶段被分为了compile和link两个阶段：
directives一般没有compile fn，但肯定有link fn。
directives创造isolated scope for directive

自定义指令:
x-*, data-*, ngBind, ng-bind, ng:bind等等，都可以匹配到。
指令注册在模块上，module.directive()
  restrict: A/E/AE (匹配属性名/匹配元素名/都匹配)
  templateUrl: like ngInclude
  可以使用scope来创造隔离作用域，这样也无法访问controller的变量.如果要使你的组件在应用范围内可重用，
  那么使用scope选项去创建一个独立作用域

  操作DOM通常在link: function (scope, element, attrs){}中定义: scope (angular中的是scope， element是angular
  内部jqLite封装的对象，attrs 驼峰形式的属性值对)

  transclude: true (相当于vue里的slot)， 如果directive里定义了scope，则无论是否在link函数里定义了scope什么的，transclude
  依然访问外部作用域，link里改写scope(directive的scope)不影响transclude的解析。但是如果directive不是isolated scope，则在
  link里的scope是父级作用域，改写的话会有问题。

  scope {
    localAttr: '=fatherScope_attr' || sameNameAttr: '=',
    localAction: '&fatherScope_prop' || samePropName: '& (index3.html)
  }

(service: $timeout, $interval)

directives之间的互相通信：(index4.html)
directive里也可以定义controller。--> 如果想暴露内部方法给别的directive的话，用controller
另一个directive里用 require: '^^controllerName' (两个^在parent的controller里找，1个^在parent or self的controller里找，
没有的话在self controller里找)，这个controller在link里是第四个参数。 
controller可以是个array： require: ['^^parentContraoller1', 'selfController2']

双向数据绑定：同时也方便测试

controller： 
intialize $scope object, add behavior and functions for $scope.
controller should contains business logics only.

this keeps the controller's constructor function out of the global scope.
expression还可以这么写 in inline style: 
method: function double()
然后: {{ double(args) }}

The most common way to keep Controllers slim is by encapsulating work that doesn't belong to controllers 
into services and then using these services in Controllers via dependency injection

ngController='SpicyController' (建议最好大写)

controller之间的scope的继承： 根据我现在的理解，基本就是继承关系。子scope可以override parent scope的属性。
MainController
  ChildController
    GrandChildController

这个例子里有4个scope: rootScope + 3 scopes of controllers

SERVICES：
- lazily instantiated; - Singletons – Each component dependent on a service gets a reference to the single 
  instance generated by the service factory.

useful build-in services such as : $http, $interval, $timeout, $log, etc
service的调用方法取决于service的return对象。(services/index.html)

create services: Application developers are free to define their own services by registering the service's
name and service factory function, with an Angular module.
return: function | object

第二种注册service的方法： via the $provide service inside of a module's config function:
(This technique is often used in unit tests to mock out a service's dependencies.)

=====================================
PROVIDERS:
Value：只能运行阶段访问。

就像Value图纸一样，Factory图纸能创建任何类型的服务，不管是原生类型，对象常量，函数，甚至自定义类型的实例。

service: 适用于创造自定义类型。

Provider图纸从语法上来说，只是一个实现了$get方法的自定义类型。
当你需要为在应用运行前就必须设置好的全局配置项提供API时，你才需要用到Provider图纸。
在应用引导阶段，也就是在Angular开始创建服务之前，Angular配置和实例化所有provider。我们把这个过程称为应用生命周期的配置阶段。
在这个阶段中，服务不能被访问，因为它们根本都还没有被创建
一旦配置阶段结束，与provider的交互就被禁止了，而创建服务的过程开始。我们把应用生命周期的这个阶段叫做运行阶段。

constant图纸：
既然配置函数运行在没有服务可用的配置阶段，那么它就连由Value图纸创建的简单值对象都无法访问。
constant: 配置和运行阶段都可以访问 --> 存在的意义。

专用对象：早先我们也提到过和服务不同的专用对象。这些对象作为插件扩展了Angular框架，因此必须实现Angular指定的接口。
这些接口就是控制器，指令，过滤器和动画。
创建这些专用对象（控制器对象除外）的注入器指令幕后其实使用的也是Factory图纸。

综上所述，我们总结如下最重要的几点：
注入器使用图纸创建两类对象：服务和专用对象。
总共有5类图纸来定义如何创建对象：Value，Factory，Service，Provicer以及Constant。
Factory和Service是最常用的图纸。它们之间的唯一区别就是Service图纸在创建自定义对象时更适用，而Factory还可以创建
Javascript原始类型以及函数。
Provider图纸是最核心的图纸类型，而其它所有图纸都只是基于它的语法糖。
Provider也是最复杂的图纸类型，除非你正在构建需要全局配置的可复用代码，否则不要使用它。
除了控制器，其他所有专用对象都是通过Factory图纸来定义的。

=====================================

SCOPE: 作用域
作用域可以监听 表达式 的变化并传播事件 ($watch)
During the template linking phase the directives set up $watch expressions on the scope.:
controller - scope -view
directive - scope - view
controller and directive 之间并没有直接联系。scope扮演了粘合剂的作用。

Notice that Angular automatically places ng-scope class on elements where scopes are attached.
从DOM元素中抓取scope： angular.element($0).scope(); $rootScope在 ngApp节点上抓取。

scope之间相当于js里的原型继承。

基于scope的事件传播： broadcasted | emitted
ng-click="$broadcast('MyEvent')" | ng-click="$emit('MyEvent')" 
$scope.$on('MyEvent', fn)

原声js上下文 和 angular执行上下文： 如果当浏览器控制权跑到原生js上下文中，angularjs就无法检测到数据变化了，这时候
需要调用$scope.$apply(expression) 来进入angularJS的上下文。

$apply() --> $digest() (遍历所有$watch监测的表达式并与之前的值比较：dirty check | 异步进行) --> 渲染DOM

scope life cycle:
1. register root scope by $injector; during template linking, directives create children scopes;
2. register watchs of model change
3. scope.$apply() data change process 
4. $digest()
5. $scope.$destroy()

scope and directives:
- type 1： 监测型指令： {{ expression }}， 这些需要在$watch上注册一个监听处理器。
- type 2:  监听型指令： ng-click="fn()", 通过$apply(fn()) 来更新DOM视图

综上，无论是哪种类型的指令，当外部事件（可能是用户输入，定时器，ajax等）发生时，相关的 表达式 必须要通过 $apply() 
作用于相应的作用域，这样所有的监听器才能被正确更新，然后进行后续的相关操作。

=====================================
DEPENDENCY INJECTION
为了分离“创建依赖”的职责，每个 Angular 应用都有一个 injector对象。这个 injector 是一个服务定位器，负责创建和查找依赖。
(三种依赖注入方式.js)

工厂方法负责创建 Angular 中的绝大多数对象。例如指令，服务，和过滤器等

strict dependency injection: 不允许implicite annotation
<html ng-app ng-strict-di> 


TEMPLATE
4 types of elements and attributs allowed to use in templates:
directive, Markup, filters, form controls 

EXPRESSION
不能直接使用window, document, location, use $window, $document, $window instead
不能用control flow such as: {{ a? b: c }}
ng-click, ng-focus 等directive里内置$event (jquery like object)
one-time binding: {{ ::name }} //第一次得到一个un-undefined value就不变化了

Interpolation:
<img src="img/{{relativeUrl}}.jpg" alt="image">
boolean attribute: ng-disabled/checked/selected/required/read-only, etc

ngAttr for binding to arbitrary attributes: ng-attr-cx, etc

You can also access the scope with this in your templates:
<div ng-show="this['form' + $index].$invalid"></div>

do not mix interpolation and expressions is bad practice such as:
<div ng-show="form{{$index}}.$invalid"></div>

===============================
Filters
The underlying API is the $filterProvider.

{{ expression | filter }}
{{ expression | filter1 | filter2 | ... }}
{ expression | filter:argument1:argument2:... }} : e.g. {{ currentNbs | number:2}}
build-in filters: currency, number, date, json, limitTo, orderBy, uppercase, lowercase

基本类型只有值变化的时候才重新执行filter，object类型每次$digest都执行一次。

Using filters in controllers, services, and directives

If you wish to namespace your filters, then you can use capitalization 
(myappSubsectionFilterx) or underscores (myapp_subsection_filterx).


===============================
Form
其中 novalidate 属性用于禁用浏览器自带的表单验证功能。<form novalidate>
为了允许对表单和控件自定义样式， ngModel 增加了如下的CSS类： - ng-valid - ng-invalid - ng-pristine - ng-dirty
The value of ngModel won't be set unless it passes validation for the input field

To allow styling of form as well as controls, ngModel adds these CSS classes:
ng-valid, ng-invalid, ng-pristine, ng-dirty (值变了), ng-touched

A form is an instance of FormController. The form instance can optionally be published 
into the scope using the name attribute.
This allows us to extend the above example with these features:

Custom error message displayed after the user interacted with a control (i.e. when $touched is set)
Custom error message displayed upon submitting the form ($submitted is set),
 even if the user didn't interact with a control


form.uEmail.$error.email
form.uEmail.$touched
form.uName.$error.required
form.$submitted

model flags: uEmail.$dirty, uEmail.$invalid, uEmail.$pristine
Custom model update triggers: ng-model-options="{ updateOn: 'blur default' }"
debounce validation/update: 
ng-model-options="{ debounce: 500 }" 
或者
"{ updateOn: 'default blur', debounce: { default: 500, blur: 0 } }"

Similarly, an input control that has the ngModel directive holds an instance of NgModelController.

自定义validator:
controller.$validators: 设置directive， require: 'ngModel', 写link function里：
ctrl.{{custo-validator-name}} = function(modelValue, viewValue) {return true | false},
然后 view里: ng-show = form.fieldname.$error.custo-validator-name

controller.$asyncValidators: 设置directive， require: 'ngModel', 写link function里：
ctrl.{{custo-validator-name}} = function(modelValue, viewValue) {
  var obj = promise 
  if (...) obj.resolve()
  else obj.reject()
  return obj
},
然后 view里: ng-show = form.fieldname.$pending.custo-validator-name;
ng-show=form.fieldname.$error.custo-validator-name;

可以overwrite build-in validators；和custom validator一个道理，然后：
ctrl.$validators.email = function (modelValue, viewValue) {/****/}

========================
components
component is a special kind of directive

how to register: .component(name, component_config_object)
It's also possible to add components via $compileProvider in a module's config phase.

bindings: 不推荐=, (two-way binding.), 应该用one way binding: <, 但是object 和 array还是会改变parent scope, 所以还是
要注意。string推荐用@
output用& 

lifecycle: 
$onInit(), after all controllers on an elements' binding are initialized, before pre&postlink
$onChange(changeObj), one-way binding is updated.
$onDestroy(), 
$postlink()： called after controller and its elements have been linked

总结： bindings在controller对象里。controller.$onInit = function(){//do something}
行内要用到ctroller的属性，用$ctrl
controller和scope是两回事。在行内直接用的属性，就是在scope上定义的。
ng-switch
  ng-switch-when
  ng-switch-default

bindings类型里，如果可以缺省的话，则加个❓， 
e.g. 
bindings: {
  fieldType: '@?'
}

使用ngRoute:$routeProvider (ngRoute_usereference.js)

inter-component communication
Note that the required controllers will not be available during the instantiation of the controller,
 but they are guaranteed to be available just before the $onInit method is executed!



 ngRouteComponent:

 <ng-outlet></ng-outlet>
 The Root Router is the starting point for all navigation. 
 You can access this Router by injecting the $rootRouter service.

 We define the top level Root Component by providing a value for the $routerRootComponent service.
myModule.value('$routerRootComponent', 'myApp');

Remember to instantiate this Root Component in our index.html file.
<my-app></my-app>
When we navigate to any given URL, the $rootRouter matches its Route Config against the URL. 
If a Route Definition in the Route Config 
recognizes a part of the URL then the Component associated with the Route Definition
is instantiated and rendered in the Outlet.

Remember that the module.component() helper automatically provides the Component's 
Controller as the $ctrl property on the scope of the template.

=================
module (module/index.html)
ou can think of a module as a CONTAINER for the different parts of your app – controllers, 
services, filters, directives, etc.

While the example above is simple, it will not scale to large applications. Instead we recommend that you break 
your application to multiple modules like this:

A module for each feature
A module for each reusable component (especially directives and filters)
And an application level module which depends on the above modules and contains any initialization code.

A module is a collection of providers, services, directives etc., and optionally config and run blocks which get 
applied to the application during the bootstrap process.

Beware that using angular.module('myModule', []) will create the module myModule and overwrite any existing module 
named myModule. Use angular.module('myModule') to retrieve an existing module.

========================
decorators
decorators are functions that allow a service, directive or filter to be modified prior to its usage.
$provide.decorator
module.decorator
Each provide access to a $delegate, which is the instantiated service/directive/filter, prior to being passed 
to the service that required it.

module.decorator是$provide.decorator的语法糖。
Since you can apply multiple decorators, it is noteworthy that decorator application always follows order 
of declaration
the service has been declared multiple times, a decorator will decorate the service that has been declared last: